{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Flask-MongoDB is a Flask extension for connecting one or more MongoDB databases to a Flask instance. This extension also includes collection model classes, model view, serializers, and model serializers. Installation Currently, the package is not in pip. However, you can install the package with pip by pulling from GitHub with the following command: pip install git+https://github.com/juanmanuel96/flask-mongodb This will install the latest stable version of the package. Quick Start This quick start guide will help you set up a Flask application with Flask-MongoDB. Configuration The first step is to set the Flask configurations. Flask-MongoDB only has two configurations: DATABASE and MODELS . The former tells the MongoDB instance to which databases to connect to, while the latter tells the instance where the models are located. The DATABASE configuration must be a dictionary of dictionaries where the first level key is the database alias for the application and the value dictionary must have the host, port, database name, and username and password if it applies. You can connect as many databases as you want. They can even come from different hosts. Flask-MongoDB has default values for both configurations: # Database configuration DATABASE = { 'main': { 'HOST': 'localhost', 'PORT': 27017, 'NAME': 'main' } } # Models configuration MODELS = [] The DATABASE and MODELS configuration will be covered in more detail later in the documentation Connecting your database to Flask Connecting you database to your Flask instance is the same as in any other Flask extension. First create your Flask instance. from flask import Flask app = Flask(__name__) Import the MongoDB class and instanciate it. from flask import Flask from flask_mongodb import MongoDB app = Flask(__name__) mongo = MongoDB() To connect your MongoDB instance to the Flask instance, you have two options: Pass the Flask instance as parameter of the MongoDB instantiation Use the factory method and call the init_app method from MongoDB passing a Flask instance as parameter. Starting the database Before actually running the application, you must create the database (or databases) and their collections. Run the following command to create the databases of your application. flask-mongodb shift start-db --all This is part of the CLI tool of the package, which will be covered later in the documentation.","title":"Home"},{"location":"#overview","text":"Flask-MongoDB is a Flask extension for connecting one or more MongoDB databases to a Flask instance. This extension also includes collection model classes, model view, serializers, and model serializers.","title":"Overview"},{"location":"#installation","text":"Currently, the package is not in pip. However, you can install the package with pip by pulling from GitHub with the following command: pip install git+https://github.com/juanmanuel96/flask-mongodb This will install the latest stable version of the package.","title":"Installation"},{"location":"#quick-start","text":"This quick start guide will help you set up a Flask application with Flask-MongoDB.","title":"Quick Start"},{"location":"#configuration","text":"The first step is to set the Flask configurations. Flask-MongoDB only has two configurations: DATABASE and MODELS . The former tells the MongoDB instance to which databases to connect to, while the latter tells the instance where the models are located. The DATABASE configuration must be a dictionary of dictionaries where the first level key is the database alias for the application and the value dictionary must have the host, port, database name, and username and password if it applies. You can connect as many databases as you want. They can even come from different hosts. Flask-MongoDB has default values for both configurations: # Database configuration DATABASE = { 'main': { 'HOST': 'localhost', 'PORT': 27017, 'NAME': 'main' } } # Models configuration MODELS = [] The DATABASE and MODELS configuration will be covered in more detail later in the documentation","title":"Configuration"},{"location":"#connecting-your-database-to-flask","text":"Connecting you database to your Flask instance is the same as in any other Flask extension. First create your Flask instance. from flask import Flask app = Flask(__name__) Import the MongoDB class and instanciate it. from flask import Flask from flask_mongodb import MongoDB app = Flask(__name__) mongo = MongoDB() To connect your MongoDB instance to the Flask instance, you have two options: Pass the Flask instance as parameter of the MongoDB instantiation Use the factory method and call the init_app method from MongoDB passing a Flask instance as parameter.","title":"Connecting your database to Flask"},{"location":"#starting-the-database","text":"Before actually running the application, you must create the database (or databases) and their collections. Run the following command to create the databases of your application. flask-mongodb shift start-db --all This is part of the CLI tool of the package, which will be covered later in the documentation.","title":"Starting the database"},{"location":"api/","text":"API Reference This part of the documentation covers all of the interfaces Flask-MongoDB has to offer. The MongoDB object class flask_mongodb.MongoDB ( app=None ) The MongoDB object connects your Flask instance to a MongoDB server. To configure the application, you may pass the Flask app during the instantiation of the MongoDB object or using the init_app method. meth disconnect ( using='main' ) Closes the connection of the desired database by alias. Parameters using : Alias of the database to disconnect. property collections Returns a dictionary of the registered collections per database alias. property connections Returns a dictionary of the MongoDatabase instances per database alias. Collection Models class flask_mongodb.models.collection.BaseCollection () The CollectionModel object is a representation of the collection in the database. attr collection_name The name of the collection in the database. This attribute MUST be given or an error will be raised. attr db_alias ='main' Default detabase alias the collection belongs to. attr schemaless =False Defines if your collection has a schema or not. attr validation_level ='strict' MongoDB collection validation level. attr manager_class = CollectionManager Manager class for the collection. property manager Property for the manager instance. proterty fields Property for the model's fields. property pk Property for the _id field of the model, the primary key. meth connect () Create a connection between your model and the collection. NOTE: This requires your application to be at the top of the context stack. meth disconnect () Disconnect your model from the collection. meth save ( bypass_validation=False ) Save model data in the database. Parameters session : Pymongo session. bypass_validation : Bypass document validation at the database level. While the option is available, it should be use as little as possible to avoid bad data in database. comment : A comment for the insert or update command. class flask_mongodb.CollectionModel ( **field_values ) Inherits from BaseCollection. Base class for all your models to inherit from. Use keyword arguments to give initial values to your desired fields. meth set_model_data ( data ) Sets the model fields values with the provided data. The data parameter must be a dictionary where the keys must be strings. Parameters data : Data to give each field, keys must be string with the name of the fields property collection Property for getting the MongoCollection instance. Will return None if the model hasn't been connected. Model fields class flask_mongodb.models.fields.Field ( required=True, allow_null=False, default=None, clean_data_func=None ) Base class for all fields to inherit from. Parameters required : Determine if the field is required, default True allow_null : Determine if null values are allowed, default False default : Default value of the field, default None clean_data_func : Function to be executed when fetching the field value, default None meth set_data ( value ) This method sets the field's value. It must be overriden by child classes to properly assign the value with the correct type. Parameters value : Value to set for the field meth get_data () Returns the field's value. This method does not need to be overriden, but you can if you wish to do some opertation before the data is returned. meth run_validation ( value ) Method for running the field's validate_data method if it has not been validated. Parameters value : Value to be validated meth validate_data ( value ) Method for validating the incomming data for the field. After it has been ran, it sets the _validated flag to True. When creating a custom field, this method's super must be executed after the validation logic. Parameters value : Value to be validated meth clean_data () Exevutes the clean_data_func if it has been provided, otherwise returns the field's value. meth clear () Clears the field's value, sets it to None. property data Property for the field's value. If the data is callable, the function is executed and the return value is returned. Otherwise, executes the get_data method. class flask_mongodb.models.fields.ObjectIdField ( required=True, allow_null=False, default=ObjectId ) Field type that represents an ObjectId item in a MongoDB collection. class flask_mongodb.models.fields.StringField ( min_length=0, max_length=0, required=True, allow_null=False, default='' ) Field type that represents an string item in a MongoDB collection. class flask_mongodb.models.fields.PasswordField Inherits from StringField , but hashes the data. class flask_mongodb.models.fields.IntegerField ( required: bool = True, allow_null=False, default=0 ) Field type that represents an integer item in a MongoDB collection. class flask_mongodb.models.fields.FloatField ( required: bool = True, allow_null=False, default=0.0 ) Field type that represents a double item in a MongoDB collection. Managers class flask_mongodb.models.manager.BaseManager ( model=None ) Manager class for all models. Takes in the current model as parameter. find ( **filter ) Returns a DocumentSet with all of the found documents set by the filter. To get all documents in the collection, do not provider a filter. all () This method is the same as running the find method without any filters. find_one ( **filter ) Get the first document found by the filter. Returns in model representation of the document.as insert_one ( insert_data=None, **options ) Insert a single document into the database. With the options kwargs, you can pass pymongo and MongoDB optins to the pymongo counterpart method. update_one ( query, update, update_type='$set', **options ) Update the first document that meets the filter with the desired update. By default, the update type is set to $set but it can be modified to other MongoDB update types such as $push . delete_one ( query, **options ) Delete the first document that meets the query filter. delete_many ( query, **options ) Delete all every document that meets the query filter. class flask_mongodb.models.manager.CollectionManager ( model=None ) Main manager class for all models. When creating a custom manager class, inherit from this class. class flask_mongodb.models.manager.RefrenceManager ( model=None, field_name=None ) This manager handles the reverse references when a model has a RefrenceIdField. It inherits from the BaseManager class with only the find , all , and find_one methods enabled. DocumentSet class flask_mongodb.models.document_set.DocumentSet ( model=None ) A list-like object that represents the results of a query. Lazily loads each document in model representation. Parameters model : Model class for the document set, default None meth first () Get the first document in model representation of the query result. meth last () Get the last document in model representation of the query result. meth limit ( number ) Limit the number of documents from the query result. Parameters number : Total documents to get from a larger set meth sort ( key_or_list, direction=None ) Sort the document in the ordered desired. Use the same sorting convention you would use for a pymongo Cursor. Parameters key_or_list : Key or list of keys to apply the sorting over direction : Direction to which make the sorting, default None . Use pymongo.ASCENDING or pymongo.DESCENDING for the direction parameter meth count () Return the total number of documents from the query. run_cursor_method ( meth_name, *args, **kwargs ) Run a method from the cursor class in your document set. It cannot be a magic method (methods that begin with \"_\") nor any of the predefiend of the class, or the clone method. Parameters meth_name : Name of the method of the cursor to run *args : Args to pass to the pymongo Cursor method **kwargs : Keyword arguments to pass to the pymongo Cursor method Data Validation class flask_mongodb.forms.collection.CollectionModelForm ( formdata=None, obj=None, prefix=\"\", data=None, meta=None, instance=None, **kwargs ) WTForms.Form class extension that integrates with flask_mongodb.CollectionModel . Parameters formdata : Input data from a form of a request in the multi_dict format. obj : Any sort of object to take data from its attributes. Only used if formdata is not provided. prefix : Field name prefixes. data : Dict object where key if the field name and the value the data of field. meta : Additional values to pass to the Meta class instance : CollectionModel instance for the model property data Returns the form data in key-value pairs. meth validate ( extra_validators=None ) Overrides the wtforms.Form validate method to flag when the form was validated. Parameters extra_validators : List of functions for extra data validators. meth save ( session=None, bypass_validation=False, comment=None ) Saves the validated data in the database using the CollectionModel save method. Parameters session : Pymongo session. bypass_validation : Bypass document validation at the database level. While the option is available, it should be use as little as possible to avoid bad data in database. comment : A comment for the insert or update command. meth delete ( session=None, comment=None ) Executes the CollectionModel delete method. Parameters session : Pymongo session comment : A comment for the delete command","title":"API Reference"},{"location":"api/#api-reference","text":"This part of the documentation covers all of the interfaces Flask-MongoDB has to offer.","title":"API Reference"},{"location":"api/#the-mongodb-object","text":"class flask_mongodb.MongoDB ( app=None ) The MongoDB object connects your Flask instance to a MongoDB server. To configure the application, you may pass the Flask app during the instantiation of the MongoDB object or using the init_app method. meth disconnect ( using='main' ) Closes the connection of the desired database by alias. Parameters using : Alias of the database to disconnect. property collections Returns a dictionary of the registered collections per database alias. property connections Returns a dictionary of the MongoDatabase instances per database alias.","title":"The MongoDB object"},{"location":"api/#collection-models","text":"class flask_mongodb.models.collection.BaseCollection () The CollectionModel object is a representation of the collection in the database. attr collection_name The name of the collection in the database. This attribute MUST be given or an error will be raised. attr db_alias ='main' Default detabase alias the collection belongs to. attr schemaless =False Defines if your collection has a schema or not. attr validation_level ='strict' MongoDB collection validation level. attr manager_class = CollectionManager Manager class for the collection. property manager Property for the manager instance. proterty fields Property for the model's fields. property pk Property for the _id field of the model, the primary key. meth connect () Create a connection between your model and the collection. NOTE: This requires your application to be at the top of the context stack. meth disconnect () Disconnect your model from the collection. meth save ( bypass_validation=False ) Save model data in the database. Parameters session : Pymongo session. bypass_validation : Bypass document validation at the database level. While the option is available, it should be use as little as possible to avoid bad data in database. comment : A comment for the insert or update command. class flask_mongodb.CollectionModel ( **field_values ) Inherits from BaseCollection. Base class for all your models to inherit from. Use keyword arguments to give initial values to your desired fields. meth set_model_data ( data ) Sets the model fields values with the provided data. The data parameter must be a dictionary where the keys must be strings. Parameters data : Data to give each field, keys must be string with the name of the fields property collection Property for getting the MongoCollection instance. Will return None if the model hasn't been connected.","title":"Collection Models"},{"location":"api/#model-fields","text":"class flask_mongodb.models.fields.Field ( required=True, allow_null=False, default=None, clean_data_func=None ) Base class for all fields to inherit from. Parameters required : Determine if the field is required, default True allow_null : Determine if null values are allowed, default False default : Default value of the field, default None clean_data_func : Function to be executed when fetching the field value, default None meth set_data ( value ) This method sets the field's value. It must be overriden by child classes to properly assign the value with the correct type. Parameters value : Value to set for the field meth get_data () Returns the field's value. This method does not need to be overriden, but you can if you wish to do some opertation before the data is returned. meth run_validation ( value ) Method for running the field's validate_data method if it has not been validated. Parameters value : Value to be validated meth validate_data ( value ) Method for validating the incomming data for the field. After it has been ran, it sets the _validated flag to True. When creating a custom field, this method's super must be executed after the validation logic. Parameters value : Value to be validated meth clean_data () Exevutes the clean_data_func if it has been provided, otherwise returns the field's value. meth clear () Clears the field's value, sets it to None. property data Property for the field's value. If the data is callable, the function is executed and the return value is returned. Otherwise, executes the get_data method. class flask_mongodb.models.fields.ObjectIdField ( required=True, allow_null=False, default=ObjectId ) Field type that represents an ObjectId item in a MongoDB collection. class flask_mongodb.models.fields.StringField ( min_length=0, max_length=0, required=True, allow_null=False, default='' ) Field type that represents an string item in a MongoDB collection. class flask_mongodb.models.fields.PasswordField Inherits from StringField , but hashes the data. class flask_mongodb.models.fields.IntegerField ( required: bool = True, allow_null=False, default=0 ) Field type that represents an integer item in a MongoDB collection. class flask_mongodb.models.fields.FloatField ( required: bool = True, allow_null=False, default=0.0 ) Field type that represents a double item in a MongoDB collection.","title":"Model fields"},{"location":"api/#managers","text":"class flask_mongodb.models.manager.BaseManager ( model=None ) Manager class for all models. Takes in the current model as parameter. find ( **filter ) Returns a DocumentSet with all of the found documents set by the filter. To get all documents in the collection, do not provider a filter. all () This method is the same as running the find method without any filters. find_one ( **filter ) Get the first document found by the filter. Returns in model representation of the document.as insert_one ( insert_data=None, **options ) Insert a single document into the database. With the options kwargs, you can pass pymongo and MongoDB optins to the pymongo counterpart method. update_one ( query, update, update_type='$set', **options ) Update the first document that meets the filter with the desired update. By default, the update type is set to $set but it can be modified to other MongoDB update types such as $push . delete_one ( query, **options ) Delete the first document that meets the query filter. delete_many ( query, **options ) Delete all every document that meets the query filter. class flask_mongodb.models.manager.CollectionManager ( model=None ) Main manager class for all models. When creating a custom manager class, inherit from this class. class flask_mongodb.models.manager.RefrenceManager ( model=None, field_name=None ) This manager handles the reverse references when a model has a RefrenceIdField. It inherits from the BaseManager class with only the find , all , and find_one methods enabled.","title":"Managers"},{"location":"api/#documentset","text":"class flask_mongodb.models.document_set.DocumentSet ( model=None ) A list-like object that represents the results of a query. Lazily loads each document in model representation. Parameters model : Model class for the document set, default None meth first () Get the first document in model representation of the query result. meth last () Get the last document in model representation of the query result. meth limit ( number ) Limit the number of documents from the query result. Parameters number : Total documents to get from a larger set meth sort ( key_or_list, direction=None ) Sort the document in the ordered desired. Use the same sorting convention you would use for a pymongo Cursor. Parameters key_or_list : Key or list of keys to apply the sorting over direction : Direction to which make the sorting, default None . Use pymongo.ASCENDING or pymongo.DESCENDING for the direction parameter meth count () Return the total number of documents from the query. run_cursor_method ( meth_name, *args, **kwargs ) Run a method from the cursor class in your document set. It cannot be a magic method (methods that begin with \"_\") nor any of the predefiend of the class, or the clone method. Parameters meth_name : Name of the method of the cursor to run *args : Args to pass to the pymongo Cursor method **kwargs : Keyword arguments to pass to the pymongo Cursor method","title":"DocumentSet"},{"location":"api/#data-validation","text":"class flask_mongodb.forms.collection.CollectionModelForm ( formdata=None, obj=None, prefix=\"\", data=None, meta=None, instance=None, **kwargs ) WTForms.Form class extension that integrates with flask_mongodb.CollectionModel . Parameters formdata : Input data from a form of a request in the multi_dict format. obj : Any sort of object to take data from its attributes. Only used if formdata is not provided. prefix : Field name prefixes. data : Dict object where key if the field name and the value the data of field. meta : Additional values to pass to the Meta class instance : CollectionModel instance for the model property data Returns the form data in key-value pairs. meth validate ( extra_validators=None ) Overrides the wtforms.Form validate method to flag when the form was validated. Parameters extra_validators : List of functions for extra data validators. meth save ( session=None, bypass_validation=False, comment=None ) Saves the validated data in the database using the CollectionModel save method. Parameters session : Pymongo session. bypass_validation : Bypass document validation at the database level. While the option is available, it should be use as little as possible to avoid bad data in database. comment : A comment for the insert or update command. meth delete ( session=None, comment=None ) Executes the CollectionModel delete method. Parameters session : Pymongo session comment : A comment for the delete command","title":"Data Validation"},{"location":"changelog/","text":"Changelog The structure for the changelog will be the following: ## Version Number ### Features - New stuff ### Fixes - Fixed stuff ### Notes - Notes if the release has any v0.3.0 Features Sunsetting of Serializer and SerializerModel classes New CollectionModelForm class for data validation in seamless integration with WTForms Shift run and examine commands take into consideration if a field has altered its required status Fixes Fixed shift subcommands Improved shifting algorithm Improved CLI feedback v0.2.0 Features Sunsetting of the setup.py file for installing the project to adhere to PEP 518 and PEP 621 Renamed to legacy_setup.py because for some reason my PIP prioritized setup.py and because I am lazy decided to rename it before deleting it. Fixes Fixes issue with install where installing the package would fail to install some dependencies due to how imports were done. I prefer to make this change before fixing the setup file to follow best practices. Notes The reason behind the move to pyproject.toml file serves two purposes: Moves in the direction of following more PEP guidelines Resolve install issue Begin the process to publish to PyPI This is the correct path to finally have the proper PyPI package I've always dreamt about. v0.1.0 Features CollectionModel save and delete method Removed all DB schema generation from model and moved to CLI tool Fields keep track of current data and initial data New run_save and run_delete method for manager Updating a model representation data from find and find_one queries can now be saved Fixes Fixed tests to meet new package standards Removed deprecated code Fixed issues with Enum field, reference field, and how data is accessed in an embedded document field Fixed broken behaviors of CLI tool When getting a model from DocumentSet, model representation od document sets model field values as inital Notes This version reset will allow the package to be better managed and do the cleanup necessary to make the package behave better and be more efficient. Versioning restart The package originally reached version 1.8.2; however, it was decided to restart versioning (without deleting the history) since there were some errors left that needed to be managed before it was really Production ready.","title":"Changelog"},{"location":"changelog/#changelog","text":"The structure for the changelog will be the following: ## Version Number ### Features - New stuff ### Fixes - Fixed stuff ### Notes - Notes if the release has any","title":"Changelog"},{"location":"changelog/#v030","text":"","title":"v0.3.0"},{"location":"changelog/#features","text":"Sunsetting of Serializer and SerializerModel classes New CollectionModelForm class for data validation in seamless integration with WTForms Shift run and examine commands take into consideration if a field has altered its required status","title":"Features"},{"location":"changelog/#fixes","text":"Fixed shift subcommands Improved shifting algorithm Improved CLI feedback","title":"Fixes"},{"location":"changelog/#v020","text":"","title":"v0.2.0"},{"location":"changelog/#features_1","text":"Sunsetting of the setup.py file for installing the project to adhere to PEP 518 and PEP 621 Renamed to legacy_setup.py because for some reason my PIP prioritized setup.py and because I am lazy decided to rename it before deleting it.","title":"Features"},{"location":"changelog/#fixes_1","text":"Fixes issue with install where installing the package would fail to install some dependencies due to how imports were done. I prefer to make this change before fixing the setup file to follow best practices.","title":"Fixes"},{"location":"changelog/#notes","text":"The reason behind the move to pyproject.toml file serves two purposes: Moves in the direction of following more PEP guidelines Resolve install issue Begin the process to publish to PyPI This is the correct path to finally have the proper PyPI package I've always dreamt about.","title":"Notes"},{"location":"changelog/#v010","text":"","title":"v0.1.0"},{"location":"changelog/#features_2","text":"CollectionModel save and delete method Removed all DB schema generation from model and moved to CLI tool Fields keep track of current data and initial data New run_save and run_delete method for manager Updating a model representation data from find and find_one queries can now be saved","title":"Features"},{"location":"changelog/#fixes_2","text":"Fixed tests to meet new package standards Removed deprecated code Fixed issues with Enum field, reference field, and how data is accessed in an embedded document field Fixed broken behaviors of CLI tool When getting a model from DocumentSet, model representation od document sets model field values as inital","title":"Fixes"},{"location":"changelog/#notes_1","text":"This version reset will allow the package to be better managed and do the cleanup necessary to make the package behave better and be more efficient.","title":"Notes"},{"location":"changelog/#versioning-restart","text":"The package originally reached version 1.8.2; however, it was decided to restart versioning (without deleting the history) since there were some errors left that needed to be managed before it was really Production ready.","title":"Versioning restart"},{"location":"cli/","text":"The CLI Tool Flask-MongoDB comes with a CLI tool to run database operations which are very hard to run during application runtime. Some examples are creating a database and its collections, or updating a collection when a field is altered or created. To run the CLI tool, open your terminal and execute the flask-mongodb command. Commands This section will describe all the command available with the CLI tool. Note that running the base command will print out the help guide, it is the same as using the --help flag. The flask-mongodb is the main command for all other commands of the tool. Options available for this command: --version: Prints out the package version --help: Prints out the help information create-model This command will create a model file in the directory of your choosing. This command simply replaces the process of having to create manually each file or python package. Options for this command: --path: Path to where the file will be created, providing no path will create it in the location where the command is executed --package: Creates a package shift The shift CLI group is used to generate database shift. In Flask-MongoDB, database shifting is the concept of altering a collection either by creating it or modifying an existing one. One or more collections can be shifted in a single run. The CLI tool was born to satisfy this requirement of the package. This command cannot run alone on its own it has a set of subcommands that make the use of shifting possible. start-db This command creates databases to be used by your application. It should be executed once the databases have been defined in the configurations of the application. Models do not have to be created beforehand to create the database, it would be ideal but not necessary. The start-db command has an option for specifying a model to be created. Please note that with this package you can run your application without explicitly creating a database, but once you stop the application all data will be lost. This command must be run whenever a new model group has been created. Options for this command: --all, -a: Creates all databases, avoid having to run the command database by database --database, -d: Specify the database alias to be started, default is main --path, -p: Model path with dot notation --help: Display help information add-collections This command will add new collections to your database after your model group has been created. Say you have a model group called api.blog with a model called BlogPosts where the author is a StringField. Then you wish to move the author data to another model called Author . Adding this new model would require a tense workaround. With the add-collections command, you will only have to define your model run the command. This command will add all new models to the database. Options for this command: --database, -d: Specify the database to add the collections, default is main --help: Display help information examine This command will compare a collection of the database current state, specifically the schema, with the model's schema. After the examination has been completed, the command will output detailing which collections of the current database will require shifting. The examine will look for new fields, field alterations (e.g. changing a StringField to an EnumField), and removed fields. Options for this command: --database, -d: Specify the database to do the examination, by default it is set to main --collection, -c: Specify the collection name to examine --help: Display help information run The run command will execute the shifts necessary for the databases. Shifting does an examination before applying the shifts. Options for this command: --database, -d: Specify the database on which to run the shift, default is main --collection, -c: Specify the collection to run the shift history This command will go through the shift_hisotry collection of the database and print the datetime and collection name that was shifted. Options for this command: --database, -d: Specify the database to see the shift history, default is main --help: Display help information","title":"flask-mongodb"},{"location":"cli/#the-cli-tool","text":"Flask-MongoDB comes with a CLI tool to run database operations which are very hard to run during application runtime. Some examples are creating a database and its collections, or updating a collection when a field is altered or created. To run the CLI tool, open your terminal and execute the flask-mongodb command.","title":"The CLI Tool"},{"location":"cli/#commands","text":"This section will describe all the command available with the CLI tool. Note that running the base command will print out the help guide, it is the same as using the --help flag. The flask-mongodb is the main command for all other commands of the tool. Options available for this command: --version: Prints out the package version --help: Prints out the help information","title":"Commands"},{"location":"cli/#create-model","text":"This command will create a model file in the directory of your choosing. This command simply replaces the process of having to create manually each file or python package. Options for this command: --path: Path to where the file will be created, providing no path will create it in the location where the command is executed --package: Creates a package","title":"create-model"},{"location":"cli/#shift","text":"The shift CLI group is used to generate database shift. In Flask-MongoDB, database shifting is the concept of altering a collection either by creating it or modifying an existing one. One or more collections can be shifted in a single run. The CLI tool was born to satisfy this requirement of the package. This command cannot run alone on its own it has a set of subcommands that make the use of shifting possible.","title":"shift"},{"location":"cli/#start-db","text":"This command creates databases to be used by your application. It should be executed once the databases have been defined in the configurations of the application. Models do not have to be created beforehand to create the database, it would be ideal but not necessary. The start-db command has an option for specifying a model to be created. Please note that with this package you can run your application without explicitly creating a database, but once you stop the application all data will be lost. This command must be run whenever a new model group has been created. Options for this command: --all, -a: Creates all databases, avoid having to run the command database by database --database, -d: Specify the database alias to be started, default is main --path, -p: Model path with dot notation --help: Display help information","title":"start-db"},{"location":"cli/#add-collections","text":"This command will add new collections to your database after your model group has been created. Say you have a model group called api.blog with a model called BlogPosts where the author is a StringField. Then you wish to move the author data to another model called Author . Adding this new model would require a tense workaround. With the add-collections command, you will only have to define your model run the command. This command will add all new models to the database. Options for this command: --database, -d: Specify the database to add the collections, default is main --help: Display help information","title":"add-collections"},{"location":"cli/#examine","text":"This command will compare a collection of the database current state, specifically the schema, with the model's schema. After the examination has been completed, the command will output detailing which collections of the current database will require shifting. The examine will look for new fields, field alterations (e.g. changing a StringField to an EnumField), and removed fields. Options for this command: --database, -d: Specify the database to do the examination, by default it is set to main --collection, -c: Specify the collection name to examine --help: Display help information","title":"examine"},{"location":"cli/#run","text":"The run command will execute the shifts necessary for the databases. Shifting does an examination before applying the shifts. Options for this command: --database, -d: Specify the database on which to run the shift, default is main --collection, -c: Specify the collection to run the shift","title":"run"},{"location":"cli/#history","text":"This command will go through the shift_hisotry collection of the database and print the datetime and collection name that was shifted. Options for this command: --database, -d: Specify the database to see the shift history, default is main --help: Display help information","title":"history"},{"location":"collections/","text":"What are models? Flask-MongoDB has a modelling class for your collections. The idea behind the models is somewhat the same as for the Django framework. The difference stands in the complexity behind the creation of these models compared to the ones of Django. Flask-MongoDB has a philosophy of making it easier for the developer to have their MongoDB collections well-structured while still offering of having the data not so structured. A CollectionModel from Flask-MongoDB represents a collection of a particular database. It is composed of metadata, fields, and the manager. The collection metadata Its metadata are three class attributes: collection_name , db_alias , and schemaless . The first one must be specified in all models while the last two have default values main and False . By default, a collection belongs to the main database and applies schema validation at the DB level. The schemaless attribute is used to enable or disable schema validation, it does not remove the requirement of fields. Schema validation can be completely turned off from collection to collection, if the developer chooses so. A collection's fields or schema A model's fields are what define the schema of the collection. The schema of the collection are basically the keys most or all documents in the collection have. Fields by default will require some form of data. If the required flag is removed, it could be saved with a None value or some other default value. Future versions will include better methods for creating models where some can have very strict schemas while others have no schema at all, meaning the use of fields or dynamic assignments of fields. Currently, a model must have at least one field defined. Creating a model As explained in the previous section, the MODELS configuration searches for the models module inside the package path in the list. This configuration is a list of packages or locations where a models.py file or models package exists. The CollectionModel Inside a model's module, you would need to create your model class which must inherit from the CollectionModel class of Flask-MongoDB. from flask_mongodb.models import CollectionModel class BlogPost(CollectionModel): pass In this example, the BlogPost model class is set to the DB of alias main and has schema validation enabled. However, this will not work since the collection_name attribute must be defined and at least one field is required. So, define the collection name. We will later define a field. from flask_mongodb.models import CollectionModel class BlogPost(CollectionModel): collection_name = 'blog_post' Defining model fields As mentioned above, the fields are what define the schema of a document in a collection. Before we create a field in our example model, they must be explained first. Structure of fields A field describes a key in a document. It has a BSON type, a required flag, allow null flag, a default value or callable, an initial value or callable, and a clean data function. The fields have their unique characteristics. Some inherit from other field types, but do some special task or modification that justify its existence. For example, the PasswordField inherits from StringField . It modifies a bit the set_data method to hash the data that represents a password. Other characteristics are: required : Makes the field require truthy value, default is True allow_null : Permits data to be None , default is False default : A default value the field will have; can be a callable. initial : An initial value for the field; can be a callable. clean_data_func : A callable that will clean the data before it is returned. For more field specifics, refer to the API Reference section. Adding a field to the model Now that fields have been explained, let's add a field to our model. Remember that at least one field is required for each model. To add a field, import the fields module from the models module. from flask_mongodb.models import CollectionModel, fields class BlogPost(CollectionModel): collection_name = 'blog_post' title = fields.StringField(max_length=100) body = fields.StringField(min_length=25, max_length=1000) This is all that is required to create a model. The save method The CollectionModel class has a save method that will take care of inserting and updating the collection document. When you instantiate a CollectionModel, the _id field data is set to None by default. Executing the save method will evaluate the _id field. If it is None , then it will run an insert action and update the instance's _id field with the new ObjectId value. Otherwise, an update_one operation will be done. Note that the update type is a $set . The method will return the pymongo operation result. The delete method The CollectionModel class also has a delete method that will take care of deleting the current instance document representation. It will run the collection operation of delete on based on the _id of the document. The method will return the pymongo operation result. Making queries MongoDB querying system uses JSON to make DB queries. Collection models instances come with a manager attribute which can run queries. The methods for running queries with the manager have the same name as the Collection instance from pymongo. Collection Manager The manager attribute is an instance of the CollectionManager class. The collection manager has the task of making every query to the database. As mentioned above, the manager implements the same querying as pymongo but modified to meet the requirements of Flask-MongoDB. Queries can be divided into two groups: reads and writes. Read queries find : Returns a document set of copies of the model with the corresponding document values find_one : Returns a single model copy with the corresponding document values Write Queries insert_one : Inserts one single document into the collection and returns a representation of the model update_one : Updates only one document in the collection. Default update type is $set . Returns a representation of the model delete_one : Deletes a single document in the collection, returns the pymongo result delete_many : Deletes all documents that match the query, returns the pymongo result. ReferenceManager The ReferenceManager class is another manager, but for reverse references. A reverse reference is when Model A references Model B, with the reference manager Model B will have access to Model A data after instantiating the model. This manager only supports the find and find_one query methods. Document Sets The DocumentSet class is a list like class where it contains copies of the model with the corresponding values from the collection documents. Only the find and all functions of the manager return DocumentSet instances. The DocumentSet instance has a Cursor object that is the query result. Iterating through the DocumentSet will return the model representation of the current document in its model form. DocumentSet methods The DocumentSet has many custom methods and wraps many of the Cursor class methods. first method The first method returns the first document of the query result. last method Just like the first method returns the first document of the query result, the last method returns the last one. limit method The limit method limits the cursor to the first n documents. Returns self for chaining DocumentSet methods. sort method The sort method sorts the cursor by the provided keys and directions. Returns self for chaining DocumentSet methods. count method The count method returns an int representation of the total count of documents of the cursor. run_cursor_method This method allows the developer to manually run methods of the Cursor class on the DocumentSet instance which have not been defined for the DocumentSet.","title":"Models"},{"location":"collections/#what-are-models","text":"Flask-MongoDB has a modelling class for your collections. The idea behind the models is somewhat the same as for the Django framework. The difference stands in the complexity behind the creation of these models compared to the ones of Django. Flask-MongoDB has a philosophy of making it easier for the developer to have their MongoDB collections well-structured while still offering of having the data not so structured. A CollectionModel from Flask-MongoDB represents a collection of a particular database. It is composed of metadata, fields, and the manager.","title":"What are models?"},{"location":"collections/#the-collection-metadata","text":"Its metadata are three class attributes: collection_name , db_alias , and schemaless . The first one must be specified in all models while the last two have default values main and False . By default, a collection belongs to the main database and applies schema validation at the DB level. The schemaless attribute is used to enable or disable schema validation, it does not remove the requirement of fields. Schema validation can be completely turned off from collection to collection, if the developer chooses so.","title":"The collection metadata"},{"location":"collections/#a-collections-fields-or-schema","text":"A model's fields are what define the schema of the collection. The schema of the collection are basically the keys most or all documents in the collection have. Fields by default will require some form of data. If the required flag is removed, it could be saved with a None value or some other default value. Future versions will include better methods for creating models where some can have very strict schemas while others have no schema at all, meaning the use of fields or dynamic assignments of fields. Currently, a model must have at least one field defined.","title":"A collection's fields or schema"},{"location":"collections/#creating-a-model","text":"As explained in the previous section, the MODELS configuration searches for the models module inside the package path in the list. This configuration is a list of packages or locations where a models.py file or models package exists.","title":"Creating a model"},{"location":"collections/#the-collectionmodel","text":"Inside a model's module, you would need to create your model class which must inherit from the CollectionModel class of Flask-MongoDB. from flask_mongodb.models import CollectionModel class BlogPost(CollectionModel): pass In this example, the BlogPost model class is set to the DB of alias main and has schema validation enabled. However, this will not work since the collection_name attribute must be defined and at least one field is required. So, define the collection name. We will later define a field. from flask_mongodb.models import CollectionModel class BlogPost(CollectionModel): collection_name = 'blog_post'","title":"The CollectionModel"},{"location":"collections/#defining-model-fields","text":"As mentioned above, the fields are what define the schema of a document in a collection. Before we create a field in our example model, they must be explained first.","title":"Defining model fields"},{"location":"collections/#structure-of-fields","text":"A field describes a key in a document. It has a BSON type, a required flag, allow null flag, a default value or callable, an initial value or callable, and a clean data function. The fields have their unique characteristics. Some inherit from other field types, but do some special task or modification that justify its existence. For example, the PasswordField inherits from StringField . It modifies a bit the set_data method to hash the data that represents a password. Other characteristics are: required : Makes the field require truthy value, default is True allow_null : Permits data to be None , default is False default : A default value the field will have; can be a callable. initial : An initial value for the field; can be a callable. clean_data_func : A callable that will clean the data before it is returned. For more field specifics, refer to the API Reference section.","title":"Structure of fields"},{"location":"collections/#adding-a-field-to-the-model","text":"Now that fields have been explained, let's add a field to our model. Remember that at least one field is required for each model. To add a field, import the fields module from the models module. from flask_mongodb.models import CollectionModel, fields class BlogPost(CollectionModel): collection_name = 'blog_post' title = fields.StringField(max_length=100) body = fields.StringField(min_length=25, max_length=1000) This is all that is required to create a model.","title":"Adding a field to the model"},{"location":"collections/#the-save-method","text":"The CollectionModel class has a save method that will take care of inserting and updating the collection document. When you instantiate a CollectionModel, the _id field data is set to None by default. Executing the save method will evaluate the _id field. If it is None , then it will run an insert action and update the instance's _id field with the new ObjectId value. Otherwise, an update_one operation will be done. Note that the update type is a $set . The method will return the pymongo operation result.","title":"The save method"},{"location":"collections/#the-delete-method","text":"The CollectionModel class also has a delete method that will take care of deleting the current instance document representation. It will run the collection operation of delete on based on the _id of the document. The method will return the pymongo operation result.","title":"The delete method"},{"location":"collections/#making-queries","text":"MongoDB querying system uses JSON to make DB queries. Collection models instances come with a manager attribute which can run queries. The methods for running queries with the manager have the same name as the Collection instance from pymongo.","title":"Making queries"},{"location":"collections/#collection-manager","text":"The manager attribute is an instance of the CollectionManager class. The collection manager has the task of making every query to the database. As mentioned above, the manager implements the same querying as pymongo but modified to meet the requirements of Flask-MongoDB. Queries can be divided into two groups: reads and writes.","title":"Collection Manager"},{"location":"collections/#read-queries","text":"find : Returns a document set of copies of the model with the corresponding document values find_one : Returns a single model copy with the corresponding document values","title":"Read queries"},{"location":"collections/#write-queries","text":"insert_one : Inserts one single document into the collection and returns a representation of the model update_one : Updates only one document in the collection. Default update type is $set . Returns a representation of the model delete_one : Deletes a single document in the collection, returns the pymongo result delete_many : Deletes all documents that match the query, returns the pymongo result.","title":"Write Queries"},{"location":"collections/#referencemanager","text":"The ReferenceManager class is another manager, but for reverse references. A reverse reference is when Model A references Model B, with the reference manager Model B will have access to Model A data after instantiating the model. This manager only supports the find and find_one query methods.","title":"ReferenceManager"},{"location":"collections/#document-sets","text":"The DocumentSet class is a list like class where it contains copies of the model with the corresponding values from the collection documents. Only the find and all functions of the manager return DocumentSet instances. The DocumentSet instance has a Cursor object that is the query result. Iterating through the DocumentSet will return the model representation of the current document in its model form.","title":"Document Sets"},{"location":"collections/#documentset-methods","text":"The DocumentSet has many custom methods and wraps many of the Cursor class methods.","title":"DocumentSet methods"},{"location":"collections/#first-method","text":"The first method returns the first document of the query result.","title":"first method"},{"location":"collections/#last-method","text":"Just like the first method returns the first document of the query result, the last method returns the last one.","title":"last method"},{"location":"collections/#limit-method","text":"The limit method limits the cursor to the first n documents. Returns self for chaining DocumentSet methods.","title":"limit method"},{"location":"collections/#sort-method","text":"The sort method sorts the cursor by the provided keys and directions. Returns self for chaining DocumentSet methods.","title":"sort method"},{"location":"collections/#count-method","text":"The count method returns an int representation of the total count of documents of the cursor.","title":"count method"},{"location":"collections/#run_cursor_method","text":"This method allows the developer to manually run methods of the Cursor class on the DocumentSet instance which have not been defined for the DocumentSet.","title":"run_cursor_method"},{"location":"forms/","text":"CollectionModelForm To validate data for a collection model, Flask-MongoDB comes prepackaged with a class called CollectionModelForm . This class is an extension of the Form class of WTForms. How to use In this section, we shall create a CollectionModelForm linked with your collection model and how to use it. Creating a form The following example demonstrates how to create a form. from flask_mongodb.forms.collection import CollectionModelForm from flask_mongodb.forms.meta import CollectionModelFormMeta from flask_mongodb.models import CollectionModel, fields from wtforms import StringField, validators class MyModel(CollectionModel): collection_name = 'my_collection' field1 = fields.StringField() class FormExample(CollectionModelForm): class Meta(CollectionModelFormMeta): model = MyModel field1 = StringField(validators=[validators.DataRequired()]) # Make sure field requirements match that of the model The first thing you should notice is the Meta class in the form. While typically this is hidden when normally creating a WTForms Form object, it should be defined for the CollectionModelForm class since you need to define which model the form is related to. This Meta class must always inherit from CollectionModelFormMeta and specify the model with the model attribute. You should then define the form fields. To avoid issues with the model field's requirements, make sure to add all needed validators to the field that match the field requirements. This is also very important for the DataRequired since by default fields of WTForms are not required and in FlaskMongoDB they are. Validating data Form data validation is done as you would for any other WTForms form validation. The following is an example of such operation. data = { 'field1': 'sample text' } form = FormExample(data=data) form.validate() The recommended use for the form is to pass data to the form using the data parameter. However, the formdata parameter will work as well. Saving form data After the form has been instantiated and validated, you can use the form's save method to save the data in the database. You can save as follows. form.save() This method will raise a WTForms ValidationError if the save operation is attempted and the validate method has not been called. Some more notes The instance attribute Every time you save the form, the form's instance attribute is updated. This attribute is the instantiated model with the data assigned as its initial values. It can then be accessed without the need to make a find_one operation. _id field All CollectionModel classes have an automatic field labeled _id . It represents the _id field of a document in a MongoDB collection. WTForms does not like fields that begin with an underscore (_). For this reason, all CollectionModelForm objects come with a field labeled oid . It stands for ObjectId, and it's a renaming of the _id field. To get it as _id , the data method replaces oid with _id when ever called. EmbeddedDocumentField in the form If your collection has an EmbeddedDocumentField in the model, you can recreate this with the FormField field class of WTForms. The FormField class takes a Form object as one of its arguments. Simply, create a new Form class (you can use WTForms Form class or CollectionModelForm class) with the fields and field requirements matching that of the EmbeddedDocumentField and pass it to the FormField object. Here is an example. from flask_mongodb.forms.collection import CollectionModelForm from flask_mongodb.forms.meta import CollectionModelFormMeta from flask_mongodb.models import CollectionModel, fields from wtforms import Form, FormField, StringField class MyModel(CollectionModel): collection_name = 'my_model' top_level_field = fields.StringField(required=False) embedded_document = fields.EmbeddedDocumentField(required=False, properties={ 'sample_field': fields.StringField(required=False) }) class EmbeddedDocumentForm(Form): sample_field = StringField() class MySampleForm(CollectionModelForm): class Meta(CollectionModelFormMeta): model = MyModel top_level_field = StringField() embedded_document = FormField(EmbeddedDocumentForm) Use the form as you would use any other CollectionModelForm. Integration with Flask-WTF As of this moment, the CollectionModelForm does not integrate well with Flask-WTF's FlaskForm. The Meta class in FlaskForm is defined the same way you would define the meta class here. While this issue is resolved, a workaround is to copy the CSRF stuff from the FlaskForm to the Meta class of CollectionModelForm as well as the FlaskForm method validate_on_submit .","title":"Forms"},{"location":"forms/#collectionmodelform","text":"To validate data for a collection model, Flask-MongoDB comes prepackaged with a class called CollectionModelForm . This class is an extension of the Form class of WTForms.","title":"CollectionModelForm"},{"location":"forms/#how-to-use","text":"In this section, we shall create a CollectionModelForm linked with your collection model and how to use it.","title":"How to use"},{"location":"forms/#creating-a-form","text":"The following example demonstrates how to create a form. from flask_mongodb.forms.collection import CollectionModelForm from flask_mongodb.forms.meta import CollectionModelFormMeta from flask_mongodb.models import CollectionModel, fields from wtforms import StringField, validators class MyModel(CollectionModel): collection_name = 'my_collection' field1 = fields.StringField() class FormExample(CollectionModelForm): class Meta(CollectionModelFormMeta): model = MyModel field1 = StringField(validators=[validators.DataRequired()]) # Make sure field requirements match that of the model The first thing you should notice is the Meta class in the form. While typically this is hidden when normally creating a WTForms Form object, it should be defined for the CollectionModelForm class since you need to define which model the form is related to. This Meta class must always inherit from CollectionModelFormMeta and specify the model with the model attribute. You should then define the form fields. To avoid issues with the model field's requirements, make sure to add all needed validators to the field that match the field requirements. This is also very important for the DataRequired since by default fields of WTForms are not required and in FlaskMongoDB they are.","title":"Creating a form"},{"location":"forms/#validating-data","text":"Form data validation is done as you would for any other WTForms form validation. The following is an example of such operation. data = { 'field1': 'sample text' } form = FormExample(data=data) form.validate() The recommended use for the form is to pass data to the form using the data parameter. However, the formdata parameter will work as well.","title":"Validating data"},{"location":"forms/#saving-form-data","text":"After the form has been instantiated and validated, you can use the form's save method to save the data in the database. You can save as follows. form.save() This method will raise a WTForms ValidationError if the save operation is attempted and the validate method has not been called.","title":"Saving form data"},{"location":"forms/#some-more-notes","text":"","title":"Some more notes"},{"location":"forms/#the-instance-attribute","text":"Every time you save the form, the form's instance attribute is updated. This attribute is the instantiated model with the data assigned as its initial values. It can then be accessed without the need to make a find_one operation.","title":"The instance attribute"},{"location":"forms/#_id-field","text":"All CollectionModel classes have an automatic field labeled _id . It represents the _id field of a document in a MongoDB collection. WTForms does not like fields that begin with an underscore (_). For this reason, all CollectionModelForm objects come with a field labeled oid . It stands for ObjectId, and it's a renaming of the _id field. To get it as _id , the data method replaces oid with _id when ever called.","title":"_id field"},{"location":"forms/#embeddeddocumentfield-in-the-form","text":"If your collection has an EmbeddedDocumentField in the model, you can recreate this with the FormField field class of WTForms. The FormField class takes a Form object as one of its arguments. Simply, create a new Form class (you can use WTForms Form class or CollectionModelForm class) with the fields and field requirements matching that of the EmbeddedDocumentField and pass it to the FormField object. Here is an example. from flask_mongodb.forms.collection import CollectionModelForm from flask_mongodb.forms.meta import CollectionModelFormMeta from flask_mongodb.models import CollectionModel, fields from wtforms import Form, FormField, StringField class MyModel(CollectionModel): collection_name = 'my_model' top_level_field = fields.StringField(required=False) embedded_document = fields.EmbeddedDocumentField(required=False, properties={ 'sample_field': fields.StringField(required=False) }) class EmbeddedDocumentForm(Form): sample_field = StringField() class MySampleForm(CollectionModelForm): class Meta(CollectionModelFormMeta): model = MyModel top_level_field = StringField() embedded_document = FormField(EmbeddedDocumentForm) Use the form as you would use any other CollectionModelForm.","title":"EmbeddedDocumentField in the form"},{"location":"forms/#integration-with-flask-wtf","text":"As of this moment, the CollectionModelForm does not integrate well with Flask-WTF's FlaskForm. The Meta class in FlaskForm is defined the same way you would define the meta class here. While this issue is resolved, a workaround is to copy the CSRF stuff from the FlaskForm to the Meta class of CollectionModelForm as well as the FlaskForm method validate_on_submit .","title":"Integration with Flask-WTF"},{"location":"mongo/","text":"The MongoDB Class The main class of Flask-MongoDB is MongoDB . This class is the one that establishes the connection between he Flask app and the database. It is written the same way all Flask extensions write their code. The class has an optional app parameter and the init_app method. That method is the preferred way of creating the connection. When a connection has been established, the Flask instance will have a new attribute called mongo . It can be accessed with the current_app proxy or the actual Flask instance. Configurations The MongoDB class has two configuration variables. These are DATABASE and MODELS . The first one tells the MongoDB instance which databases and connections to use. The MODELS configuration tells the instance where to look for those models. The elements of the list are referred to as model groups. Database settings As mentioned above, the database configuration has default values. This default value connects the Flask app to a database of name main in localhost on port 27017, where the database alias is main. Structure DATABASE = { 'DB alias': { 'HOST': 'host of the database', 'PORT': 'port of the database', 'NAME': 'name of the database' } } Example DATABASE = { 'main': { 'HOST': 'localhost', 'PORT': 27017, 'NAME': 'main' } } The main alias should always be present since by default all models are connected to main. However, it is up to you for setting the DB alias names for other database connections. It is recommended that in your configurations add a DATABASE variable to overwrite the default configurations and connect to your database. Remember that once you start the application, if the database does not exist it is created automatically. In your DATABASE variable, the first key is the database alias. Its value should be another dictionary with the following keys: HOST - Host where the database is located (required) PORT - Port of the database (required) NAME - Name of the database in the connection (required) USERNAME - Username of the account to be used to conduct the DB operations (optional) PASSWORD - Password of the account, required if username is used (optional) These DB configurations needs to be repeated for all databases you wish to connect to the application. Make sure not to repeat aliases. Models configuration The MODELS configuration provides is the main method for registering models to the MongoDB instance automatically and easily. To register models automatically, simply add to the list the package path to the models. For exmaple, if you have a project with the following structure: api |__ __init__.py |__ authentication |__ models |__ __init__.py |__ users.py |__ views |__ ... |__ store |__ models |__ __init__.py |__ inventory.py |__ views |__ ... You would want to register your authentication and store models automatically. In your configurations, create a new variable called MODELS. This variable must be a list. You should add api.authentication and api.store to the MODELS variable. Note that you do not add \"models\" to each of the package paths because the MongoDB instance will automatically search for models inside your packages. Your MODELS variable should look like this: MODELS = [ 'api.authentication', 'api.store' ] If you were to install other packages with Flask-MongoDB models, you would add the path to those models in the MODELS configuration as well. The models file can be treated as package or as a simple file with all of the models in it. Using the MongoDB instance at runtime After you have registered the models and created your endpoints, you will most likely want to use the MongoDB instance through your application to make database operations. This section will explain how to get the MongoDB instance throughout your application. App context When running a Flask application and importing certain modules or variables, it matters in which context you are making the call. There are proxies for the current application and request, for example. When you initialize the MongoDB object with the Flask instance, the Flask instance gets a new attribute called mongo which is the initialized MongoDB object. This creates two methods of importing the current MongoDB instance in the application context. Current App proxy Using the current_app proxy, you can access the instanced MongoDB object through it by accessing the mongo attribute. With the mongo attribute you will have access to all of your MongoDB instance methods and attributes. from flask import current_app mongo = current_app.mongo Current mongo proxy Besides using the current_app proxy, you can use the current_mongo proxy. This proxy basically gets the mongo attribute from the current app and returns it. This makes the calls to the mongo instance to be shorter. Importing the MongoDB instance In your app initialization file, you have to initialize your MongoDB instance after the Flask instance. After initialization, you can call the MongoDB instance directly like you would with the Flask instance. There is a caveat, though. This will not work with the app factory method or might raise import errors depending on how and where you make the import in your application. This method is highly discouraged. Using models at runtime While developing your application, you will want to use the models. You can import any of your models as you would import any other class in Python. To use the model, simply initialize it, and you can do model operations with it. Remember that whenever making queries or doing database operation, make them inside the application context.","title":"The MongoDB Class"},{"location":"mongo/#the-mongodb-class","text":"The main class of Flask-MongoDB is MongoDB . This class is the one that establishes the connection between he Flask app and the database. It is written the same way all Flask extensions write their code. The class has an optional app parameter and the init_app method. That method is the preferred way of creating the connection. When a connection has been established, the Flask instance will have a new attribute called mongo . It can be accessed with the current_app proxy or the actual Flask instance.","title":"The MongoDB Class"},{"location":"mongo/#configurations","text":"The MongoDB class has two configuration variables. These are DATABASE and MODELS . The first one tells the MongoDB instance which databases and connections to use. The MODELS configuration tells the instance where to look for those models. The elements of the list are referred to as model groups.","title":"Configurations"},{"location":"mongo/#database-settings","text":"As mentioned above, the database configuration has default values. This default value connects the Flask app to a database of name main in localhost on port 27017, where the database alias is main. Structure DATABASE = { 'DB alias': { 'HOST': 'host of the database', 'PORT': 'port of the database', 'NAME': 'name of the database' } } Example DATABASE = { 'main': { 'HOST': 'localhost', 'PORT': 27017, 'NAME': 'main' } } The main alias should always be present since by default all models are connected to main. However, it is up to you for setting the DB alias names for other database connections. It is recommended that in your configurations add a DATABASE variable to overwrite the default configurations and connect to your database. Remember that once you start the application, if the database does not exist it is created automatically. In your DATABASE variable, the first key is the database alias. Its value should be another dictionary with the following keys: HOST - Host where the database is located (required) PORT - Port of the database (required) NAME - Name of the database in the connection (required) USERNAME - Username of the account to be used to conduct the DB operations (optional) PASSWORD - Password of the account, required if username is used (optional) These DB configurations needs to be repeated for all databases you wish to connect to the application. Make sure not to repeat aliases.","title":"Database settings"},{"location":"mongo/#models-configuration","text":"The MODELS configuration provides is the main method for registering models to the MongoDB instance automatically and easily. To register models automatically, simply add to the list the package path to the models. For exmaple, if you have a project with the following structure: api |__ __init__.py |__ authentication |__ models |__ __init__.py |__ users.py |__ views |__ ... |__ store |__ models |__ __init__.py |__ inventory.py |__ views |__ ... You would want to register your authentication and store models automatically. In your configurations, create a new variable called MODELS. This variable must be a list. You should add api.authentication and api.store to the MODELS variable. Note that you do not add \"models\" to each of the package paths because the MongoDB instance will automatically search for models inside your packages. Your MODELS variable should look like this: MODELS = [ 'api.authentication', 'api.store' ] If you were to install other packages with Flask-MongoDB models, you would add the path to those models in the MODELS configuration as well. The models file can be treated as package or as a simple file with all of the models in it.","title":"Models configuration"},{"location":"mongo/#using-the-mongodb-instance-at-runtime","text":"After you have registered the models and created your endpoints, you will most likely want to use the MongoDB instance through your application to make database operations. This section will explain how to get the MongoDB instance throughout your application.","title":"Using the MongoDB instance at runtime"},{"location":"mongo/#app-context","text":"When running a Flask application and importing certain modules or variables, it matters in which context you are making the call. There are proxies for the current application and request, for example. When you initialize the MongoDB object with the Flask instance, the Flask instance gets a new attribute called mongo which is the initialized MongoDB object. This creates two methods of importing the current MongoDB instance in the application context.","title":"App context"},{"location":"mongo/#current-app-proxy","text":"Using the current_app proxy, you can access the instanced MongoDB object through it by accessing the mongo attribute. With the mongo attribute you will have access to all of your MongoDB instance methods and attributes. from flask import current_app mongo = current_app.mongo","title":"Current App proxy"},{"location":"mongo/#current-mongo-proxy","text":"Besides using the current_app proxy, you can use the current_mongo proxy. This proxy basically gets the mongo attribute from the current app and returns it. This makes the calls to the mongo instance to be shorter.","title":"Current mongo proxy"},{"location":"mongo/#importing-the-mongodb-instance","text":"In your app initialization file, you have to initialize your MongoDB instance after the Flask instance. After initialization, you can call the MongoDB instance directly like you would with the Flask instance. There is a caveat, though. This will not work with the app factory method or might raise import errors depending on how and where you make the import in your application. This method is highly discouraged.","title":"Importing the MongoDB instance"},{"location":"mongo/#using-models-at-runtime","text":"While developing your application, you will want to use the models. You can import any of your models as you would import any other class in Python. To use the model, simply initialize it, and you can do model operations with it. Remember that whenever making queries or doing database operation, make them inside the application context.","title":"Using models at runtime"}]}